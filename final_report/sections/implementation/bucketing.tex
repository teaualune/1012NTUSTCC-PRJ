\subsection{Key-to-reducer Bucketing}

For our server-browser model, the intermediate output data from mappers are sent to the server first and then dispatches to reducers. For each key generated by the mappers, it should be assigned to a specified reducer so that the reducer can sum up the value of the key; so, it is important that for any key-value pair data, they should be sent to the same reducer if the keys is identical.

To achieve this, we need an assignment, i.e. a mapping, from keys to reducers, in the shuffle step. The assignment must ensures that the same key goes to the same reducer; moreover, the assignment should amortize the number of keys each reducers received in order to achieve good load balancing.

We use an idea similar to the bucketing to solve this issue. A key pool is given and initialized as an empty object in the congiguration step; to retrieve a client with a given key, the pool accepts the key as the input and

(1) checks whether the key is already in the pool;

(2) if the key is not in the pool, it assigns a new client ID (retrieved via an iterator on the client pool) to the key and store the key-client ID pair into the key pool. Finally the pool returns the ID;

(3) if the key is found, the pool returns the client ID assigned on the key.

Note that in (2) we ensures the load balancing by using the iterator on the client pool, since the iterator will go through clients in the pool one by one; for next incoming new key, it will be assigned to the next client.

This is a relatively simple bucketing scheme but works well, for both mapping accuracy and load balancing.
